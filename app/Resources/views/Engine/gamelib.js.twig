/** prototype pour les numéros de vidéos */

Number.prototype.zeroPad = Number.prototype.zeroPad ||
     function(base){
       var nr = this, len = (String(base).length - String(nr).length)+1;
       return len > 0? new Array(len).join('0')+nr : nr;
    };

/** prototype pour les string tout remplacer */
String.prototype.replaceAll = function(search, replacement) {
    var target = this;
    return target.replace(new RegExp(search, 'g'), replacement);
};

/** stratégie de resizing de la scène **/

function onWindowResize() {

  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );
  composer.reset();

}

/* Changement pour le mapping de la vidéo sur la forme */

function change_uvs( geometry, unitx, unity, offsetx, offsety ) {
  var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  var uvs = faceVertexUvs[ 8 ];

    for ( var j = 0; j < uvs.length; j ++ ) {

      var uv = uvs[ j ];
      // console.log(uv0.x,uv0.y);
      // uv0.x = ( uv0.x + 1 ) ;
      // uv0.y = ( uv0.y + 0 ) ;
      uv.x = ( uv.x + offsetx ) * unitx;
      uv.y = ( uv.y + offsety ) * unity;
  }
}

function changeVideoChoiceWithKeypressed(nextLock,keycode,keyTrue,videoGameOver,footerDelay = 0){
  if(nextLock){
    if(keycode == keyTrue){
      changeVideo(nextLock,footerDelay);
      lastVideoPlayed["val"] = nextLock;
      return nextLock;
    }else{
      changeVideo(videoGameOver,footerDelay);
      return false;
    }
  }
}

/* Changement de la vidéo sur la texture de l'objet */
function changeVideo(numberVideo, footerDelay = 0, pause = false){
  //console.log(numberVideo);
  videoElt = document.getElementById( 'video_'+numberVideo );
  videoElt.pause();
  videoElt.currentTime = 0;
  videoElt.setAttribute('autoplay',true);
  videoElt.play();
  if(pause){
    videoElt.pause();
  }

  if(!active){
    TweenLite.to(mesh_0.material, 0.17, {opacity: 0});
    mesh_0.material.needsUpdate = true;
    mesh_0.updateMatrix();

    texture_1 = new THREE.VideoTexture( videoElt );
    texture_1.minFilter = THREE.LinearFilter;
    texture_1.magFilter = THREE.LinearFilter;
    texture_1.format = THREE.RGBFormat;

    mesh_1.material.map = texture_1;
    mesh_1.material.needsUpdate = true;
    TweenLite.to(mesh_1.material, 0.08, {opacity: 1});


  }else{
      TweenLite.to(mesh_1.material, 0.17, {opacity: 0});
      mesh_1.material.needsUpdate = true;
      mesh_1.updateMatrix();

      texture_0 = new THREE.VideoTexture( videoElt );
      texture_0.minFilter = THREE.LinearFilter;
      texture_0.magFilter = THREE.LinearFilter;
      texture_0.format = THREE.RGBFormat;

      mesh_0.material.map = texture_0;
      mesh_0.material.needsUpdate = true;
      TweenLite.to(mesh_0.material, 0.08, {opacity: 1});

  }
  active = !active;
  console.log(footerDelay);
  $( "#footer" ).animate({
    bottom: "-80px"
  }, footerDelay, function() {
    //$("#footer").hide();
  });
}

/** KeyBoardAzerty **/
var keyboardAzerty = ["97","122","101","114","116","121","117","105","111","112","113","115","100","102","103","104","106","107","108","109","119","120","99","118",
"98","110","44","59"];

/** mapping keyBoard **/
function createMappedKeyboard(firstVideo,lastVideo,random = false){
  var numberVideo = lastVideo - firstVideo + 2;
  var mappedKeyboard = [];

  if(random){
    for (var key in keyboardAzerty) {
      mappedKeyboard[keyboardAzerty[key]] = Math.floor(Math.random() * (Math.floor(lastVideo) - Math.ceil(firstVideo) +1)) + Math.ceil(firstVideo);
    }
    return mappedKeyboard;
  }

  var currentVid = firstVideo;

  for (var key in keyboardAzerty) {
    if(!(currentVid % numberVideo)){
      currentVid=firstVideo;
    }
    mappedKeyboard[keyboardAzerty[key]] = currentVid;
    currentVid++;
  }
  return mappedKeyboard;
}


function loadText(textStr,footerDelay, is3D = false){
  if(is3D){
    loadText3D(textStr);
  }else{
    loadTextFooter(textStr,footerDelay);
  }
}

function loadTextFooter(textStr,footerDelay){
  var text = textStr.replaceAll("\n", "<br/>");
  $("#footer").show();
  $("#footer span.text").html(text);
  $( "#footer" ).animate({
    bottom: "0px"
    }, footerDelay, function() {
  });
  if(!text){
    $("#footer").hide();
    bottom: "-80px"
  }
}

function loadText3D(textStr) {
  var loader = new THREE.FontLoader();

				textMaterial = [
					new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } ), // front
					new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading } ) // side FlatShading
				];
  loader.load( '/fonts/' + fontName + '_' + fontWeight + '.typeface.json', function ( response ) {
    font = response;
    scene.remove( textMesh );
    if ( !textStr ) return;
    textGeo = new THREE.TextBufferGeometry( textStr, {
      font: font,
      size: textSize,
      height: textHeight,
      curveSegments: textCurveSegments,
      bevelThickness: bevelThickness,
      bevelSize: bevelSize,
      bevelEnabled: bevelEnabled,
      material: 0,
      extrudeMaterial: 1
    });
    textGeo.computeBoundingBox();
    textGeo.computeVertexNormals();
    var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
          textMesh = new THREE.Mesh( textGeo, textMaterial );
          textMesh.position.x = centerOffset;
          textMesh.position.y = -140;
          textMesh.position.z = 0;
          textMesh.rotation.x = 0;
          textMesh.rotation.y = Math.PI * 2;
          scene.add( textMesh );

  } );
}
