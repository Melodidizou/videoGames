if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var container;

var camera, scene, renderer;

var video, texture, material, mesh;

var composer;

var mouseX = 0;
var mouseY = 0;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var   material;


var keyboardAzerty = ["97","122","101","114","116","121","117","105","111","112","113","115","100","102","103","104","106","107","108","109","119","120","99","118",
"98","110","44","59"];

var mappedKeyboard = [];


init();
animate();

function init() {

  container = document.createElement( 'div' );
  document.body.appendChild( container );

  camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
  camera.position.z = 500;

  scene = new THREE.Scene();
  var loader = new THREE.TextureLoader();
  var light = new THREE.DirectionalLight( 0xffffff );
  light.position.set( 0.5, 2, 1 ).normalize();
  scene.add( light );

  renderer = new THREE.WebGLRenderer( { antialias: false } );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

// getFirstSequence()
  video = document.getElementById( 'video_00' );
  video.setAttribute('autoplay',true);

  texture = new THREE.VideoTexture( video );
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.format = THREE.RGBFormat;
  texture.needsUpdate = true;

  var geometry, xsize, ysize;

  xsize = 350 ;
  ysize = 280 ;
  zsize = 50 ;

  var parameters = { color: 0xffffff, map: texture };

  material = new THREE.MeshLambertMaterial( parameters );

  geometry = new THREE.BoxGeometry( xsize, ysize, zsize );


// game.getIsMappedVideo
  // change_uvs( geometry, 1, 1, 0.1, 0 );

    mesh = new THREE.Mesh( geometry, material );

    mesh.position.x = 0;
    mesh.position.y = 0;
    mesh.position.z = 0;

    mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;

    scene.add( mesh );

  renderer.autoClear = false;

  document.addEventListener( 'mousemove', onDocumentMouseMove, false );

  // postprocessing

  var renderModel = new THREE.RenderPass( scene, camera );
  var effectBloom = new THREE.BloomPass( 1.3 );
  var effectCopy = new THREE.ShaderPass( THREE.CopyShader );

  effectCopy.renderToScreen = true;

  composer = new THREE.EffectComposer( renderer );

  composer.addPass( renderModel );
  composer.addPass( effectBloom );
  composer.addPass( effectCopy );


  window.addEventListener( 'resize', onWindowResize, false );

  mappedKeyboard = createMappedKeyboard(1,16);
  console.log(mappedKeyboard);
}

/* fct à mettre dans lib */

function onWindowResize() {

  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );
  composer.reset();

}

/* fct à mettre dans lib */

function change_uvs( geometry, unitx, unity, offsetx, offsety ) {

  var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  console.log(faceVertexUvs.length);
  for ( var i = 0; i < faceVertexUvs.length; i ++ ) {

    var uvs = faceVertexUvs[ i ];

    for ( var j = 0; j < uvs.length; j ++ ) {

      var uv = uvs[ j ];

     uv.x = ( uv.x + offsetx ) * unitx;
     uv.y = ( uv.y + offsety ) * unity;

    }

  }

}

// game.velocityX velocityY
function onDocumentMouseMove(event) {

  mouseX = ( event.clientX - windowHalfX ) * 0.3;
  mouseY = ( event.clientY - windowHalfY ) * 0.3;

}

//

function animate() {

  requestAnimationFrame( animate );

  render();

}

var h, counter = 1;

function render() {

  var time = Date.now() * 0.0005;

  camera.position.x += ( mouseX - camera.position.x ) * 0.04;
  camera.position.y += ( - mouseY - camera.position.y ) * 0.04;

  camera.lookAt( scene.position );
  renderer.clear();
  composer.render();

}

/** fct lib */

Number.prototype.zeroPad = Number.prototype.zeroPad ||
     function(base){
       var nr = this, len = (String(base).length - String(nr).length)+1;
       return len > 0? new Array(len).join('0')+nr : nr;
    };


function changeVideo(i){
  video_01 = document.getElementById( 'video_'+i );
  video_01.pause();
  video_01.currentTime = 0;
  video_01.setAttribute('autoplay',true);
  video_01.play();

  texture = new THREE.VideoTexture( video_01 );
  texture.minFilter = THREE.LinearFilter;
  texture.magFilter = THREE.LinearFilter;
  texture.format = THREE.RGBFormat;
  var parameters = { color: 0xffffff, map: texture };
  material = new THREE.MeshLambertMaterial( parameters );

  mesh.material.map = texture;
  mesh.material.needsUpdate = true;

}



function createMappedKeyboard(firstVideo,lastVideo,random = false){
  var numberVideo = lastVideo - firstVideo;
  var mappedKeyboard = [];
  var currentVid = firstVideo;

  for (var key in keyboardAzerty) {
    mappedKeyboard[keyboardAzerty[key]] = currentVid;
    currentVid++;
    if(!(currentVid % numberVideo)){
        currentVid=firstVideo;
    }
  }
  return mappedKeyboard;
}

/** fct à isoler dans game transition*/

$(document).keypress(function(e) {
  var code = e.keyCode || e.which;
  if(mappedKeyboard[code] == undefined){
    console.log("Key not mapped "+e.keyCode+" "+code);
  }else{
    changeVideo(mappedKeyboard[code].zeroPad(10));
  }
  
});
